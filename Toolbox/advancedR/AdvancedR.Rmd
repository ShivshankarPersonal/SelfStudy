---
title: "<strong>Advanced `R`</strong>"
author: "andrés castro araújo"
date: "`r Sys.Date()`"
output: 
  html_document: 
    theme: lumen
    toc: yes
    toc_float: 
      collapsed: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "", fig.align = "center")

# library(tidyverse)
# theme_set(theme_minimal(base_family = "Avenir", base_line_size = 0))

library(magrittr)
```


```{r results="asis", echo=FALSE}
cat('
<style>
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    color: #9C9C9C;
    border-left: 10px solid #EEE;
}
</style>
')
```

>Taken from Hadley Wickham. [__Advanced R__](https://adv-r.hadley.nz). CRC Press, 2019.

****

## Introduction

Somethings about `R` are different from what you'd expect to see in other programming languages. 

- Copy-on-modify semantics, which makes sense once we really understand the difference between an object and its name.

- In `R`, almost everything is a vector. 

- There are three subsetting operators, `[[`, `[`, and `$`, and all of them interact in different ways with different vector types.

- R has aspects of both functional and object-oriented (OO) programming languages.


## Copy-on-modify semantics

We’ll use the `lobstr` package to dig into the internal representation of R objects.

```{r}
library(lobstr)
```

Suppose we want to contain an object `x` that contains the values 1, 2, and 3.

```{r}
x <- c(1, 2, 3)
```

But this is _not_ an object with a name. R first creates a vector of values `c(1,2,3)` and then binds that object to a name `x`. 

>In other words, the object, or value, doesn’t have a name; it’s actually the name that has a value.

Thus, names are actually references to values. And if we now run `y <- x`, we don't get another copy of the value `c(1,2,3)`; instead, we get another binding to the existing object.

```{r, echo=FALSE, out.width="180px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/bdc72c04d3135f19fb3ab13731129eb84c9170af/f0ab9/diagrams/name-value/binding-2.png"
)
```

The `0x74b` refers to the object independently of its bindings. We can use `lobstr` to see that both `x` and `y` point to the same identifier. Note that these identifiers are long, and change every time you restart R.

```{r}
obj_addr(x)
y <- x
obj_addr(y)
```

Now suppose we modify `y`, but not `x`. 

```{r}
y[[2]] <- 100
```

R creates a new object `0xcd2`, which is basically the same as `0x74b` with one value change. Finally, the name `y` is rebound to that new object.

```{r, echo=FALSE, out.width="170px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/ef9f480effa2f1d0e401d1f94218d0cf118433c0/b56e9/diagrams/name-value/binding-3.png"
)
```

>This behaviour is called __copy-on-modify.__ Understanding it will radically improve your intuition about the performance of R code.

This, for example, explains why loops perform better when we feed them a vector of adequate size.

```{r}
output <- vector("integer", length = 3)
for (i in 1:5) {
  output[[i]] <- i
  print(obj_addr(output)) ## remains the same while vector is length = 3
}
```

__Lists__

Just like names, the elements of a list point to values as well. Instead of storing the values themselves, 

```{r}
l1 <- l2 <- list(1, 2, 3)
```

```{r, echo=FALSE, out.width="180px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/52bc0e3da3382cba957a9d83397b6c9200906ce2/c72aa/diagrams/name-value/l-modify-1.png"
)
```

```{r}
l2[[3]] <- 4
```

```{r, echo=FALSE, out.width="180px"}
knitr::include_graphics(
"https://d33wubrfki0l68.cloudfront.net/b844bb5a3443e1344299627f5760e2ae3a9885b5/e1c76/diagrams/name-value/l-modify-2.png"
)
```

>Like vectors, lists use copy-on-modify behaviour; the original list is left unchanged, and R creates a modified copy. This, however, is a __shallow copy__: the list object and its bindings are copied, but the values pointed to by the bindings are not.

We can use `lobstr::ref()` to see the values that are shared across both lists.

```{r}
lobstr::ref(l1, l2)
```

And because values are being shared, the size of lists is sometimes unintuitive. More generally, `obj_size(x)` + `obj_size(y)` will only equal `obj_size(x, y)`
if they share no values.

```{r}
x <- runif(1000)
y <- list(x, x, x)
ref(x, y)
obj_size(x) + obj_size(y)
obj_size(x, y)
```

__Data frames__

Data frames are lists of vectors, so copy-on-modify works very similar in this setting, except the following:

- "If you modify a column, only that column needs to be modified; the others will still point to their original references."

- "However, if you modify a row, every column is modified, which means every column must be copied."

****

>Note. The latests versions of R have a feature called ALTREP, short for __alternative representation__. It allows for R to represent some types of vectors very compactly. The place you are most likely to see this is with `:` because instead of storing every single number in the sequence, R just stores the first and last number.

```{r}
obj_size(c(1, 2, 3, 4, 5))
obj_size(1:5)
x <- 1:5000
obj_size(x)
x[[333]] <- 9 ## note the massive increase in size
obj_size(x) 
```

****

An important exception with regards to the copy-on-modify semantics occurs with `environments`, a special type of object that is always __modified on place__.

>This property is sometimes described as __reference semantics__ because when you modify an environment all existing bindings to that environment continue to have the same reference.

## Vectors

There are two types of vectors in R:

- __Atomic vectors__, of which there are six types: `logical`, `integer`, `double`, `character`, `complex`, and `raw.` Integer and double vectors are collectively known as _numeric_ vectors.

    You can determine the type of a vector with the `typeof()` function.

- __Lists__, which are sometimes called recursive vectors (because lists can contain other lists). Other times they're called generic vectors to emphasise their difference from atomic vectors.

The chief difference between atomic vectors and lists is that atomic vectors are _homogeneous_, while lists can be _heterogeneous._ There’s one other related object: `NULL`, which is often used to represent the absence of a vector (as opposed to `NA`, which is used to represent the absence of a value in a vector).

Most computations involving a missing value will return another missing value, with a couple of obvious exceptions:

```{r}
NA^0
NA | TRUE
NA & FALSE
```

___Attributes___

Every vector can have __attributes__ (i.e. a named list of arbitrary metadata). Two attributes are particularly important: _dimension_, which turns vectors into matrices and arrays; and _class_, which powers the S3 object system.

You can _name_ a vector in three ways:

```{r}
# When creating it: 
x <- c(a = 1, b = 2, c = 3)

# By assigning a character vector to names()
x <- 1:3
names(x) <- c("a", "b", "c")

# Inline, with setNames():
x <- setNames(1:3, c("a", "b", "c"))
```

```{r}
str(x)
```

Other attributes are set (or retrieved) with the `attr()` function,

```{r}
attr(x, "names") <- c("a", "b", "c")
attr(x, "arbitrary") <- rnorm(1)
str(x)
```

And we can extract all of them with the `attributes()` function.

```{r}
attr(x, "arbitrary")
attributes(x) ## returns a named list
```

__Dimensions__

Adding a `dim` attribute to a vector allows it to behave like a 2-dimensional matrix or a multi-dimensional array.

```{r}
x <- 1:20
dim(x) <- c(4, 5)
x
dim(x) <- c(2, 5, 2)
x
```

Note that many of the functions for working with vectors have generalisations for matrices and arrays:

```{r, echo=FALSE}
knitr::kable(
tibble::tibble(
  vector = c("`names()`", "`length()`", "`c()`", "", "`is.null(dim(x))`"),
  matrix = c("`rownames()`, `colnames()`", "`nrow()`, `ncol()`", "`rbind()`, `cbind()`", "`t()`", "`is.matrix()`"),
  array = c("`dimnames()`", "`dim()`", "`abind::abind()`", "`aperm()`", "`is.array()`"))
) %>% 
  kableExtra::kable_styling(full_width = FALSE, bootstrap_options = "bordered")
```

___S3 atomic vectors___

Having a __`class`__ attribute turns an object into an _S3 object_, which makes it behave differently from a regular vector when passed to a _generic function_.

Four types of important S3 vectors used in R:

- `factor` vectors, used to store categorical data. where values come Factors are built on top of an integer vector with two attributes: a "factor" `class`, which makes them behave differently from regular integer vectors; and "levels", which defines the set of allowed values.

    "Ordered factors" are a minor variation of factors (i.e. a < b < c).

- Dates (with day resolution), which are recorded in `Date` vectors. They're built on top of "double" vectors. They have a class “Date”, and no other attributes.

    The value of the double, represents the number of days since "1970-01-01" (also known as the Unix Epoch).
    
    ```{r}
    x <- 0
    class(x) <- "Date"
    x
    ```

- Date-times are much like dates, except that they also have second or sub-second resolution. These are also built on top of doubles, but they have a `POSIXct` class.

    >"POSIX" is short for Portable Operating System Interface, which is a family of cross-platform standards. "ct" standards for calendar time (the `time_t` type in C).

    ```{r}
    x <- as.POSIXct("1990-03-04 2:00", tz = "UTC")
    x
    attributes(x)
    attr(x, which = "tzone") <- "EST"
    x
    ```

    >The `tzone` attribute controls only how the date-time is formatted; it does not control the instant of time represented by the vector.
    
    EST stands for Eastern Daylight Time, whereas UTC stands for [Universal Time Coordinated](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).

- Durations, which are stored in `difftime` vectors. They're built on top of doubles and have an additional units attribute that determines how to interpret the numeric value.

    ```{r}
    x - x
    class(x - x)
    as.difftime(1.5, units = "weeks")
    ```

___Lists___

Every element of a list can be of any type. Technically speaking, however, each element of list is really a reference (or a binding) to another object, which can be of any type.

>This makes them fundamentally different from atomic vectors.

You can turn a list into an atomic vector with `unlist()`. But the rules for the resulting type are complex and not well documented.

The most important S3 vectors that are built upon lists are data frames and tibbles. In both cases, the length of each of its vectors must be the same. 

```{r}
typeof(mtcars)
attributes(mtcars)
```

Tibbles, on the other hand, are provided by the [__`tibble`__](https://tibble.tidyverse.org/) package.

>A concise, and fun, way to summarise the main differences is that tibbles are lazy [they don't coerce their input (e.g. `stringsAsFactors = FALSE`)] and surly: they do less and complain more.

```{r}
library(tibble)
df <- tibble(x = 1:3, y = LETTERS[1:3])
typeof(df)
attributes(df)
```

But perhaps the biggest difference between data frames and tibbles is that the later are designed to disregard rownames.

```{r}
attributes(as_tibble(mtcars))
```

>There are three reasons why row names are undesirable:
>
>1. Metadata is data, so storing it in a different way to the rest of the data is fundamentally a bad idea. It also means that you need to learn a new set of tools to work with row names; you can’t use what you already know about manipulating columns.
>
>2. Row names are a poor abstraction for labelling rows because they only work when a row can be identified by a single string. This fails in many cases, for example when you want to identify a row by a non-character vector (e.g. a time point), or with multiple vectors (e.g. position, encoded by latitude and longitude).
>
>3. Row names must be unique, so any duplication of rows (e.g. from bootstrapping) will create new row names. If you want to match rows from before and after the transformation, you’ll need to perform complicated string surgery.
>
>For these reasons, tibbles do not support row names. Instead the tibble package provides tools to easily convert row names into a regular column with either `rownames_to_column()`, or the `rownames` argument in `as_tibble()`.

Finally, making use of _list-columns_ with tibbles is much easier.

>Since a data frame is a list of vectors, it is possible for a data frame to have a column that is a list. This is very useful because a list can contain any other object: this means you can put any object in a data frame. This allows you to keep related objects together in a row, no matter how complex the individual objects are.

```{r, error=TRUE}
df <- data.frame(x = 1:3)
df$y <- list(1:2, 1:3, 1:4)
df

data.frame(
  x = 1:3, 
  y = list(1:2, 1:3, 1:4)  ## This doesn't work!
)

tibble(
  x = 1:3, 
  y = list(1:2, 1:3, 1:4)
)

```

## Subsetting

>Subsetting is a natural complement to `str()`. While `str()` shows you all the pieces of any object (its structure), subsetting allows you to pull out the pieces that you’re interested in. 

R has three subsetting operators: `[`, `[[`, and `$`. The `[` operator lets you subset atomic vectors.

___Six ways to subset atomic vectors.___

```{r, error=TRUE}
## 1. Positive integers
letters[3:1]
letters[c(2, 2, 2)]
letters[c(1.9, 2.1, 2.8)] ## silently truncated to integers

## 2. Negative integers
letters[1:20 * -1]
letters[c(-1, 2)] ## can't mix!

## 3. Logical vectors
letters > "m"
letters[letters > "m"]

## 4. Nothing. Useful for matrices, data frames, and arrays
letters[]

## 5. Zero returns a zero-length vector. Usually not done on purpose
letters[0]
```

Finally, if the vector is _named_, you can use character vectors to return elements with matching names.

```{r}
## 6. Character vectors
(y <- setNames(1:4, letters[1:4]))
y["c"]
y[c("a", "a", "c", "a", "x")]
```

A final word of caution:

>Factors are not treated specially when subsetting. This means that subsetting will use the underlying integer vector, not the character levels. This is typically unexpected, so you should avoid subsetting with factors.

___Subsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames)___

- Subsetting a list will work in the same way as subsetting atomic vectors. `[` always returns a list, whereas `[[` and `$` pull elements out of a list.

- The easiest way of subsetting matrices (2D) and arrays (>2D) is to supply a 1D index for each dimension separated by a comma.

    And because both matrices and arrays are just vectors with special a `dimension` attribute, you can always subset them with a single vector (i.e. treat them as if they were a 1D vector). 
    
    Note: Arrays in R are stored in column-major order.
    
- We can also subset matrices and arrays with a matrix (integer, logical, and character if named).

    For example:

    ```{r}
    x <- outer(1:4, 1:4, FUN = "+")
    x
    upper.tri(x)
    x[upper.tri(x)]
    ```

- Subsetting a data frame with a simple index makes it behave like a list (e.g. `df[1:2]` selects the first two columns).

    Subsetting a data frame with two indices makes it behave like a matrix (e.g. `df[1:3, ]` selects the first three rows).

    >By default, subsetting a matrix or data frame with a single number, a single name, or a logical vector containing a single `TRUE`, will simplify the returned output, i.e. it will return an object with lower dimensionality. To preserve the original dimensionality, you must use `drop = FALSE`.

    Tibbles have `drop = FALSE` by default.

>_Exercise. Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix)._

```{r}
extract_diag <- function(x) {      # When subsetting with integer matrices,
  end <- min(nrow(x), ncol(x))     # each row specifies the location of one 
  return(x[cbind(1:end, 1:end)])   # value, and each column corresponds to a 
}                                  # dimension in the array.
```

___Selecting a single element___

The `[[` operator is used for extracting single items; `$`, on the other hand, is a shorthand operator: `x$y` is equivalent to `x[["y"]]`. These operators are mostly useful when working with lists, because while `[` returns a smaller list, `[[` will actually extract the content of that list.

```{r}
mtcars[["mpg"]]
identical(mtcars[["mpg"]], mtcars$mpg)
```

>Because `[[` can return only a single item, you must use it with either a single positive integer or a single string. If you use a vector with `[[`, it will subset recursively, i.e. `x[[c(1, 2)]]` is equivalent to `x[[1]][[2]]`. This is a quirky feature that few know about, so I recommend avoiding it in favour of `purrr::pluck()`.
>
>When the element is missing, `pluck()` always returns `NULL` (or the value of the .default argument) and `chuck()` always throws an error. The behaviour of `pluck()` makes it well suited for indexing into deeply nested data structures where the component you want may not exist (as is common when working with JSON data from web APIs). `pluck()` also allows you to mix integer and character indices, and provides an alternative default value if an item does not exist:

```{r, error=TRUE}
x <- list(
  a = list(1, 2, 3),
  b = list(3, 4, 5)
)

purrr::pluck(x, "a", 1)
purrr::pluck(x, "c", 1)
purrr::chuck(x, "c", 1)
purrr::pluck(x, "c", 1, .default = NA)
```

`$` is most commonly used to access variables in a data frame.

>One common mistake with `$` is to use it when you have the name of a column stored in a variable.

```{r}
var <- "mpg"
# Doesn't work - mtcars$var translated to mtcars[["var"]]
mtcars$var

# Instead use [[
mtcars[[var]]
```

Finally, `$` does left-to-right partial matching on regular data frames, which can be a frustrating source of errors. Tibbles, on the other hand, will never do partial matching.

___Subsetting and assignment___

>All subsetting operators can be combined with assignment to modify selected values of an input vector: this is called subassignment. The basic form is `x[i] <- value`. I recommend that you should make sure that length(value) is the same as length(x[i]), and that i is unique.

```{r}
x <- 1:5
x[c(1, 2)] <- c(101, 102)
x
```

You can use `x[[i]] <- NULL` to delete an element of a list; or use `x[[i]] <- list(NULL)` to replace an element with a literal `NULL` value.

## Subsetting applications

### Lookup tables (character subsetting)

```{r}
x <- c("m", "f", "u", "f", "f", "m", "m")
lookup <- c(m = "Male", f = "Female")
lookup[x]
unname(lookup[x]) ## if you don’t want names in the result
```

### Matching and merging by hand (integer subsetting)

>You can also have more complicated lookup tables with multiple columns of information. For example, suppose we have a vector of integer grades, and a table that describes their properties:

```{r}
grades <- c(1, 2, 2, 3, 1)

info <- tibble::tibble(
  grade = 3:1,
  desc = c("Excellent", "Good", "Poor"),
  fail = c(FALSE, FALSE, TRUE)
)

```

>Then, let’s say we want to duplicate the info table so that we have a row for each value in grades. An elegant way to do this is by combining `match()` and integer subsetting (`match(needles, haystack)` returns the position where each `needle` is found in the `haystack`).

```{r}
id <- match(grades, info$grade) 
id
info[id, ] 
```

>Note that `match()` returns a vector of the positions of (first) matches of its first argument in its second.

### Random samples and bootstraps (integer subsetting)

>You can use integer indices to randomly sample or bootstrap a vector or data frame. Just use sample(n) to generate a random permutation of 1:n, and then use the results to subset the values:

```{r}
df <- head(mtcars, n = 5) %>% tibble::as_tibble(rownames = "id")
df[sample(nrow(df), 100, replace = TRUE), ]
```

### Ordering (integer subsetting)

>`order()` takes a vector as its input and returns an integer vector describing how to order the subsetted vector. 

```{r}
x <- c("b", "c", "a")
order(x)
x[order(x)]
```

>To break ties, you can supply additional variables to `order()`. You can also change the order from ascending to descending by using `decreasing = TRUE`. By default, any missing values will be put at the end of the vector; however, you can remove them with `na.last = NA` or put them at the front with `na.last = FALSE`.

```{r}
df2 <- df[sample(nrow(df)), sample(ncol(df))] ## randomly reorder df
df2[order(df2[[1]]), ]                        ## reorder rows according to first column
df2[ , order(names(df2))]                     ## reorder rows according to first column
```

>You can sort vectors directly with `sort()`, or similarly `dplyr::arrange()`, to sort a data frame.

### Expanding aggregated counts (integer subsetting)

>Sometimes you get a data frame where identical rows have been collapsed into one and a count column has been added. `rep()` and integer subsetting make it easy to uncollapse, because we can take advantage of vectorisation: `rep(x, y)` repeats `x[i] y[i]` times.

```{r}
df <- tibble::tibble(x = c(2, 4, 1), y = c(9, 11, 6), n = c(3, 5, 1))
str(df)
rep(1:nrow(df), df$n)
df[rep(1:nrow(df), df$n), ]
```

### Removing columns from data frames (character)

>There are two ways to remove columns from a data frame. You can set individual columns to `NULL`:

```{r}
df <- data.frame(x = 1:3, y = 3:1, z = letters[1:3])
df$z <- NULL
```

>Or you can subset to return only the columns you want:

```{r}
df <- tibble::tibble(x = 1:3, y = 3:1, z = letters[1:3])
df[c("x", "y")]

## use set operations when you only know the columns you don’t want
df[setdiff(names(df), "x")]
```

### Selecting rows based on a condition (logical subsetting)

>Because logical subsetting allows you to easily combine conditions from multiple columns, it’s probably the most commonly used technique for extracting rows out of a data frame.

```{r}
mtcars[mtcars$gear == 5, ]
mtcars[mtcars$gear == 5 & mtcars$cyl == 4, ]
```

<blockquote>
Remember to use the vector boolean operators `&` and `|`, not the short-circuiting scalar operators `&&` and `||`, which are more useful inside if statements. And don’t forget De Morgan’s laws, which can be useful to simplify negations:

- `!(X & Y)` is the same as `!X | !Y`

- `!(X | Y)` is the same as `!X & !Y`
</blockquote>

### `which()`

___Boolean algebra versus sets (logical and integer)___

<blockquote>
It’s useful to be aware of the natural equivalence between set operations (integer subsetting) and Boolean algebra (logical subsetting). Using set operations is more effective when:

You want to find the first (or last) `TRUE`.

You have very few `TRUE`s and very many `FALSE`s; a set representation may be faster and require less storage.

`which()` allows you to convert a Boolean representation to an integer representation.
</blockquote>

```{r}
x <- sample(8) < 4
x
which(x)
```

>There’s no reverse operation in base R but we can easily create one:

```{r}
unwhich <- function(x, n) {
  out <- rep_len(FALSE, length.out = n)
  out[x] <- TRUE
  return(out)
}
unwhich(which(x), 8)
```

<blockquote>
When first learning subsetting, a common mistake is to use `x[which(y)]` instead of `x[y]`. Here the `which()` achieves nothing: it switches from logical to integer subsetting but the result is exactly the same. In more general cases, there are two important differences.

- When the logical vector contains `NA`, logical subsetting replaces these values with `NA` while `which()` simply drops these values. It’s not uncommon to use `which()` for this side-effect, but I don’t recommend it: nothing about the name "which" implies the removal of missing values.

- `x[-which(y)]` is __not__ equivalent to `x[!y]`: if `y` is all `FALSE`, `which(y)` will be `integer(0)` and `-integer(0)` is still `integer(0)`, so you’ll get no values, instead of all values.

In general, avoid switching from logical to integer subsetting unless you want, for example, the first or last `TRUE` value.
</blockquote>

>Exercise. _How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?_

```{r}
df <- head(mtcars, 10)
df[sample(nrow(df)), sample(ncol(df))]
```

## Control Flow

<blockquote>
-__Choices__, like `if` statements and `switch()` calls, allow you to run different code depending on the input. 

-__Loops__, like `for` and `while`, allow you to repeatedly run code, typically with changing options.
</blockquote>

___Choices___

```{r, eval=FALSE}
# The basic form of an "if" statement in R
if (condition) true_action
if (condition) true_action else false_action
```

`if` statements also return values, which in turn can be used for assignments.

```{r}
x <- if (TRUE) 1; x
x <- if (FALSE) 1; x ## invisibly returns a NULL
x <- if (FALSE) 1 else 2; x
```

>The `condition` should evaluate to a single `TRUE` or `FALSE`. Most other inputs will generate an error:

```{r, error=TRUE}
if ("x") 1
if (logical()) 1
if (NA) 1
```

>The exception is a logical vector of length greater than 1, which generates a warning:

```{r}
if (c(TRUE, FALSE)) 1
```

>In R 3.5.0 and greater, thanks to [Henrik Bengtsson](https://github.com/HenrikBengtsson/Wishlist-for-R/issues/38), you can turn this into an error by setting an environment variable:

```{r, error=TRUE}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
if (c(TRUE, FALSE)) 1
```

>Handling vectors of logical values is the job of `ifelse()`: a vectorised function with `test`, `yes`, and `no` vectors (that will be recycled to the same length).

```{r}
x <- 1:10
ifelse(x %% 5 == 0, "XXX", as.character(x))
ifelse(x %% 2 == 0, "even", "odd")
```

>Another vectorised equivalent is the more general `dplyr::case_when()`. It uses a special syntax to allow any number of condition-vector pairs:

```{r}
dplyr::case_when(
  x %% 3 == 0 & x %% 5 == 0 ~ "fizz buzz", 
  x %% 3 == 0 ~ "fizz",
  x %% 5 == 0 ~ "buzz",
  is.na(x) ~ "[?]",
  TRUE ~ as.character(x)
)
```

>Closely related to `if` is the `switch()` statement. It’s a compact, special purpose equivalent that lets you replace code like:

```{r}
x_option <- function(x) {
  if (x == "a") {
    "option 1"
  } else if (x == "b") {
    "option 2" 
  } else if (x == "c") {
    "option 3"
  } else {
    stop("Invalid `x` value")
  }
}
```

>with the more succint:

```{r}
x_option <- function(x) {
  switch(x,
    "a" = "option 1",
    "b" = "option 2",
    "c" = "option 3",
    stop("Invalid `x` value")
  )
}
```

>The last component of a `switch()` should always throw an error, otherwise unmatched inputs will invisibly return `NULL`.

___Loops___

```{r, eval=FALSE}
# The basic form of a "loop" in R
for (item in vector) perform_action
```

>Note. `for` assigns the item to the current environment, overwriting any existing variable with the same name.

_Two ways to terminate a loop early:_

1. `next` exits the current iteration.

2. `break` exits the entire loop.

```{r}
for (i in 1:10) {
  if (i < 3) next

  print(i)
  
  if (i >= 5) break
}
```

_Three common pitfalls of `for` loops_

1. If you’re generating data, make sure to preallocate the output container. Otherwise the loop will be very slow (see copy-on-modify semantics).

    ```{r}
    x <- 1:10
    out <- vector("list", length(x))
    for (i in 1:length(out)) out[[i]] <- rnorm(10, x[[i]])
    ```

2. Beware of iterating over `1:length(x)`, which will fail in unhelpful ways if `x` has length 0.

    ```{r, error=TRUE}
    x <- numeric()
    out <- vector("list", length(x))
    for (i in 1:length(out)) out[[i]] <- rnorm(10, x[[i]])
    ```

3. Loops typically strip the attributes of S3 vectors.

```{r}
xs <- as.Date(c("2020-01-01", "2010-01-01"))
for (k in xs) print(k)  ## no longer a date
for (k in seq_along(xs)) print(xs[[k]])
```

We use `while` and `repeat` when we need to use loops, but we don't know in advance the set of values that we want to iterate over.

>You can rewrite any `for` loop to use `while` instead, and you can rewrite any `while` loop to use `repeat`, but the converses are not true. That means `while` is more flexible than `for`, and `repeat` is more flexible than `while.` It’s good practice, however, to use the least-flexible solution to a problem, so you should use `for` wherever possible.

- `while(condition) action`: performs `action` while `condition` is `TRUE`.

- `repeat(action)`: repeats `action` forever (i.e. until it encounters `break`).

    Note that R doesn't have the common `do {action} while (condition)` syntax found in other languages.

>Generally speaking you shouldn’t need to use for loops for data analysis tasks, as `map()` and `apply()` already provide less flexible solutions to most problems.

## Functions

### Basics

Two important ideas:

<blockquote>
1. Functions are objects, just as vectors are objects.

2. Functions can be broken down into three components: arguments, body, and environment.

    There are exceptions to every rule, and in this case, there is a small selection of "primitive" base functions that are implemented purely in C.
</blockquote>

The three parts of any function can be accessed with `formals()`, `body()`, and `environment()`.

```{r}



```






### Composition

### Lexical scoping

### ???

### `...`

### Exit

### Disguise












