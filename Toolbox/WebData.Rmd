---
title: "Getting Web Data"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    theme: paper
    toc: yes
    toc_float:
      collapsed: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
library(tidyverse)
```

## HTTP

**Getting data from the web**

Basics of HTTP (or HypterText Transfer Protocol).

- A system of rules about data exchange between computers.

You can think of this as a conversation between a client and a server. We, as clients, get to ask different things through different *HTTP requests* (or methods).

```{r, out.width="60%", echo=FALSE}
knitr::include_graphics("figures/client_request.png")
```

Request messages are sent via **Uniform Resource Locators** (URLs):

$$
\underbrace{\texttt{http:}}_\text{protocol} \texttt{//}
\underbrace{\texttt{www.domain.com}}_\text{host} \texttt{/}
\underbrace{\texttt{path/to/resource}}_\text{resource path}
\underbrace{\texttt{?a=b&x=y}}_\text{query}
$$

We can construct URLs by stitching together different parts of the URL. In general, API URLs will ....


https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1--net-31177

https://www.jmarshall.com/easy/http/

****

A safer alternative to HTTP is HTTPS, which stands for *HypterText Transfer Protocol Secure*.

****

Basic HTTP methods include `GET`, `HEAD`, and `POST`.

- **`GET`** ("get me something").

    Downloading a file from the Internet means sending a `GET` request and receiving the file you asked for. Internally, most functions like `read_csv("https://...")` use a `GET` under the hood.

- **`HEAD`** ("get me metadata about something").
    
- **`POST`** ("have something of mine"). 





**Error Handling**

We use "status codes" to assess requests.

As a general rule...
2 - great!
3 - great!
4 - your code is broken
5 - their code is broken

https://en.wikipedia.org/wiki/List_of_HTTP_status_codes

## The **`httr`** package

If an API client (i.e. an R package) doesn't exist, it's up to you to communicate directly with the API. We can do this through the [**`httr`**](https://httr.r-lib.org/) package. 

- API stands for Application Programming Interface. It's a set of routines and protocols for building software components and how they interact. They are "like websites, but for machines".

    Web APIs serve as interfaces to get or add data to a server, using HTTP methods.

The `httr::GET()` function will execute this request. The result is a **response object**, that provides easy access to the status code, content-type and (of course) the actual content.

You can extract the content from the request using the `content()` function. At the time of writing, there are three ways to retrieve this content: as a raw object, as a character vector, or an R object, such as a list. If you don't tell `content()` how to retrieve the content through the as argument, it'll try its best to figure out which type is most appropriate based on the content-type.

The `httr::POST()` request asks the server to accept something from you. They're commonly used for things like file upload, or authentication. As a result of their use for uploading things, `POST()` accepts not just a `url` but also a `body` argument containing whatever you want to give to the server.

```{r}
library(httr)
domain <- "https://api.usaspending.gov/api/v2/"
update_url <- paste(domain, "awards/last_updated/", sep = "/")
response <- GET(update_url)
response
content(response)
```

Note that the "Content-Type" is a JSON file (see **Data formats** for more information on this).

You can send additional data to the server in the url (with the `query` string) and in the `body` of `POST()`, `PUT()` and `PATCH()` requests.

A common way of sending simple key-value pairs to the server is the query string. For example: 

$$
\texttt{http://httpbin.org/get?key=val}
$$

```{r}
s_url <- paste(domain, "financial_spending/object_class", sep = "/")

query_params <- list(fiscal_year = "2018", 
                     funding_agency_id = "1068",
                     major_object_class_code = "20",
                     limit = "100")

response <- GET(s_url, query = query_params)
response
results <- content(response)$results
typeof(results)
length(results)
bind_rows(results)
```

Here's how it looks in JSON format:

```{r, comment=""}
jsonlite::prettify(content(response, as = "text"))
```


**PUT STUFF HERE**









API FOR BETTERFIN CENSUS



```{r}
spending_url <- "https://api.usaspending.gov/api/v2/spending/"

response <- POST(spending_url)
content(response)
```

```{r}

'{
    "type": "agency",
    "filters": {
        "fy": "2017"
    }
}'

## LIST WITHIN LIST?

response <- POST(spending_url, list = "agency")
content(response)
```


**Restpectful API usage**

- **`user_agent()`**: include information such as e-mail address or project URL, so that the developers running the API can contact you in case something goes wrong.

    From your end, the request looks exactly the same with or without a user agent, but it can make a big difference for the server.
    
```
GET(url, user_agent("acastroaraujo@gmail.com"))
```
    
- **Rate-limitng**: make sure you only make a certain number of requests to the server in a given time period. Your limit will vary from server to server, but the implementation is always pretty much the same and involves a call to `Sys.sleep(# seconds)`.


****

Note: It's common for API clients to require access tokens -- unique keys that verify you're authorised to use a service. Use the `config` argument to handle these types of situation.

****

## The **`rvest`** package


## Data formats

### JSON

- JSON stands for JavaScript Object Notation. JSON files are structured a lot like Python dictionaries or named lists. Most APIs work with this type of object.

The [**`jsonlite`**](https://cran.r-project.org/web/packages/jsonlite/index.html) package:

```{r}
library(jsonlite)
json_data <- '{"matrix": [[1, 2], [2, 1]],
               "vector": ["a", "b", "c", "d"]}'
  
fromJSON(json_data)
```

`fromJSON()` also works if you pass a URL as a character string or the path to a local file that contains JSON data. 

There JSON *objects* and there are JSON *arrays*.

An object:

```{r}
fromJSON('{"name": "Andy", "place": "Factory", "year": 1967}')
```

An array:

```{r}
fromJSON('{"array": [1, 2, 3, 5, 8, 13, null, false, true],
           "object": [null, 1, true, 0, false]}')
```

```{r}
fromJSON('[[1, 2], [3, 4]]')  ## array of JSON arrays
fromJSON('[{"a": 1, "b": 2},  // array of JSON objects
           {"a": 3, "b": 4},
           {"a": 5, "b": 6}]')
```

Other useful functions in the `jsonlite` package include `toJSON()`, `prettify()`, and `minify()`.

```{r}
toJSON(head(iris, n = 3))
```

```{r, comment=""}
prettify(toJSON(head(iris, n = 3)))
```

Note that many complex data structures will be represented as JSON objects, with so-called â€œchild JSON objects", which are like dictionaries stored in other dictionaries.


### XML

Like JSON, XML is a plain text format. We can check if the API returned an XML file with the `httr::http_type(response)` function. Do this to understand the structure of your document:

- `xml2::xml_structure(httr::content(response, as = "text"))`

To extract data from an XML file you would use the XPATH language.


| XPATH  	| Meaning                                                	        |
|--------	|---------------------------------------------------------------	|
| `/node`  	| Elements with `tag` "node"" at this level                   	|
| `//node` 	| Elements with `tag` "node" anywhere at or below this level 	  |
| `@attr`  	| Attribute with `name` "attr"                               	  |
